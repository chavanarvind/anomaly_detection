import numpy as np
import pandas as pd
import tensorflow as tf

# Load the CSV file
data = pd.read_csv("your_file.csv")  # Replace with your actual CSV file path

# Ensure data is sorted by date
data['date'] = pd.to_datetime(data['date'])
data = data.sort_values('date').reset_index(drop=True)

# Extract only numerical columns for the model
numerical_data = data[['pointa', 'pointb', 'pointc']]

# Scale the data (optional, depending on your data distribution)
# You can use MinMaxScaler or StandardScaler if needed
# from sklearn.preprocessing import MinMaxScaler
# scaler = MinMaxScaler()
# numerical_data = scaler.fit_transform(numerical_data)

# Create lagged data
n_lags = 3  # Number of timesteps to look back
X = []
y = []

for i in range(n_lags, len(numerical_data)):
    X.append(numerical_data.iloc[i - n_lags:i].values)  # Input sequence
    y.append(numerical_data.iloc[i].values)            # Target value

X = np.array(X)  # Shape: (samples, n_lags, features)
y = np.array(y)  # Shape: (samples, features)

# Split data into train and test sets
train_size = int(0.8 * len(X))
X_train, X_test = X[:train_size], X[train_size:]
y_train, y_test = y[:train_size], y[train_size:]

# Define LSTM model
model = tf.keras.Sequential([
    tf.keras.layers.LSTM(64, activation='relu', input_shape=(X_train.shape[1], X_train.shape[2])),
    tf.keras.layers.Dense(X_train.shape[2])  # Output layer for all features
])

# Compile the model
model.compile(optimizer='adam', loss='mse')

# Train the model
model.fit(X_train, y_train, epochs=50, batch_size=32, validation_data=(X_test, y_test))

# Forecast next 10 values
last_sequence = X_test[-1]  # Start with the last sequence in test data
n_predictions = 10  # Number of future values to predict
predicted_values = []

for _ in range(n_predictions):
    # Reshape last_sequence for prediction (batch size = 1)
    last_sequence = last_sequence.reshape(1, last_sequence.shape[0], last_sequence.shape[1])
    
    # Predict the next value
    next_value = model.predict(last_sequence, verbose=0)
    predicted_values.append(next_value[0])  # Store the prediction
    
    # Update `last_sequence` by appending the new value and removing the oldest one
    last_sequence = np.append(last_sequence[:, 1:, :], next_value.reshape(1, 1, -1), axis=1)

# Convert predictions to a DataFrame
predictions_df = pd.DataFrame(predicted_values, columns=['pointa', 'pointb', 'pointc'])

# Optionally, add future dates to the predictions DataFrame
last_date = data['date'].iloc[-1]
future_dates = [last_date + pd.Timedelta(days=i) for i in range(1, n_predictions + 1)]
predictions_df['date'] = future_dates

# Output the predictions
print("Predicted Values:")
print(predictions_df)
